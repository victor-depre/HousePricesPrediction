---
title: "House Prices Prediction"
author: "Victor Dépré"
date: "7/22/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

```{r}
library(tidyverse)
library(ggplot2) # data visualization
library(plotly) # same
library(readr) # download the data
library(caret) # to perform RF model
library(naniar) # to visualize missing data
library(data.table) # to ?????????
```

# Download the data

```{r}
train.df <- read_csv("trainhouseprices.csv")
test.df <- read_csv("testhouseprices.csv")

train.df$TrainData <- TRUE
test.df$TrainData <- FALSE
```

```{r}
str(train.df)
```

We can see that train.df contains 82 variables.

```{r}
str(test.df)
```

test.df contains only 81 variables, one less than train.df, it is the variable SalePrice that is missing.

```{r}
test.df$SalePrice <- NA
```

We add the variable SalePrice with the value NA for the test dataset.

```{r}
full.df <- rbind(train.df, test.df)
```

We merge the two datasets to perform analysis on the full data.

```{r}
head(full.df, 10)
```

Nous regardons les dix premières lignes de notre jeu de données, nous pouvons constater que certaines variables comportent des valeurs manquantes. Nous allons donc étudier quelles sont les valeurs manquantes puis essayer de définir une méthode pour les prédire.

# Gérer les valeurs manquantes

## NA sur la globalité du jeu de données

```{r}
na_count <-sapply(full.df, function(y) sum(length(which(is.na(y)))))

na_count <- data.frame(na_count)

na_count <- rownames_to_column(na_count)
na_count <- filter(na_count, na_count > 0)
na_count
```

Nous pouvons voir que les variables qui comptent le plus de valeurs manquantes sont Alley, PoolQc, MiscFeature, Fence, FirePlaceQu. Il y a 29 variables qui contiennent des valeurs nulles mais dans une moindre mesure. Il sera donc plus simple de les prédire. Enfin, la variable SalePrice contient 1459 valeurs manquantes soit le nombre de lignes du jeu de données test.

```{r}
Graph1 <- gg_miss_var(full.df)
ggplotly(Graph1)
```

Une autre manière de visualiser les valeurs manquantes de façon hiérarchique. Sur ce graphique, nous distinguons clairement 6 variables pour lesquelles nous avons plus de 1000 valeurs nulles.

Analyse des variables qui contiennent le plus de NA:

+ PoolQC, la valeur NA indique une absence de piscine, il n'y a donc aucune valeur à modifier.
+ MiscFeature, là encore, la valeur NA indique l'absence de caractéristiques supplémentaires.
+ Alley, la valeur NA indique l'absence d'allée.
+ Fence, la valeur NA indique l'absence de clôtures.
+ FireplaceQu, la valeur NA indique l'absence de cheminée. 
+ LotFrontage, ici, il va falloir déterminer si NA indique l'absence de distance entre la propriété et la rue ou alors si la valeur NA indique simplement une valeur non renseignée.

Pour éviter de fausser l'analyse de données, nous allons remplacer les valeurs NA des cinq premières variables par "Abs".
Concernant la variable LotFrontage, nous allons devoir déterminer si NA indique une distance de 0 ou s'il s'agit de valeurs non renseignées.

### NA indiquant "non"

```{r}
full.df$PoolQC[is.na(full.df$PoolQC)] = "Abs"
full.df$MiscFeature[is.na(full.df$MiscFeature)] = "Abs"
full.df$Alley[is.na(full.df$Alley)] = "Abs"
full.df$Fence[is.na(full.df$Fence)] = "Abs"
full.df$FireplaceQu[is.na(full.df$FireplaceQu)] = "Abs"
```

Les valeurs indiquées comme NA pour les précédentes variables ont donc été remplacées par la valeur "Abs", cela permettra de passer ces variables en facteur au moment voulu.

### Vérification pour la variable PoolQC

```{r}
full.df[full.df$PoolArea>0 & full.df$PoolQC=="Abs", c("Id", 'PoolArea', 'PoolQC', 'OverallQual')]
```

Nous constatons qu'il y a 3 valeurs "Abs" pour la variable PoolQC alors que la variable PoolArea indique une taille de piscine (donc la présence d'une piscine sur la propriété). Il s'agit donc d'une erreur de saisie ou d'une omission pour la variable PoolQC sur les lignes.
Pour remplacer les valeurs manquantes de PoolQC, nous nous baserons sur la qualité globale de la maison (OverallQual).

```{r}
full.df$PoolQC[2421] <- "Fa"
full.df$PoolQC[2504] <- "TA"
full.df$PoolQC[2600] <- "Fa"
```

Les valeurs ont été remplacées en prenant en compte la qualité globale de l'habitation.

### Vérification pour la variable FirePlaceQu

```{r}
full.df[full.df$Fireplaces>0 & full.df$FireplaceQu=="Abs", c("Id", 'Fireplaces', 'FireplaceQu')]
```

Il n'y a aucune erreur sur la variable FirePlaceQu, car lorsque la valeur indique "Abs", il y a effectivement aucune cheminée au sein de l'habitation.

### Valeurs manquantes Lot Frontage

```{r}
summary(full.df$LotFrontage)
```

Cette première analyse nous permet de constater que pour la variable LotFrontage, la valeur minimale est 21. Nous ne pouvons donc pas conclure que les valeurs NA représentent la valeur 0. 

```{r}
table(is.na(full.df$LotFrontage), full.df$MSZoning)
```

Dans un premier temps, nous essayons de voir s'il existe un lien entre la variable MsZoning et la variable LotFrontage. Nous décidons de faire cette analyse car il pourrait y avoir un lien par exemple entre le fait d'être en zone agricole et ainsi ne pas avoir de surface du lot bordant la rue.

Nous constatons que les valeurs manquantes pour LotFrontage semblent être distribuées de façon identique aux valeurs non-nulles de la variable. Il n'y a donc à priori aucun lien entre ces deux variables.

En étudiant les autres variables du jeu de données, nous nous apercevons qu'aucune autre ne semble pouvoir expliquer les absences de valeurs pour la variable LotFrontage. Nous allons donc devoir trouver une méthode pour prédire les valeurs de cette dernière.

```{r}
Graph2 <- ggplot(full.df[!is.na(full.df$LotFrontage),], aes(x=as.factor(Neighborhood), y=LotFrontage)) +
        geom_bar(stat='summary', fun.y = "median", fill='red') +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))
ggplotly(Graph2)
```

Nous voyons que les valeurs pour LotFrontage divergent en fonction du lieu. Nous allons donc affecter les valeurs médianes aux valeurs manquantes pour cette variable.

```{r}
full.df <- data.table(full.df)
setkey(full.df, Neighborhood)
full.df[,LotFrontage := ifelse(is.na(LotFrontage), median(LotFrontage, na.rm=TRUE), LotFrontage), by=Neighborhood]

full.df <- full.df[order(full.df$Id),]
```


### Valeurs manquantes Basement (Bsmt)

Il n'y a aucune erreur sur les variable Bsmt, car lorsque la valeur indique "Na", il y a pas de sous-sol dans l'habitation.

```{r}
full.df$BsmtQual[is.na(full.df$BsmtQual)] = "Abs"
full.df$BsmtCond[is.na(full.df$BsmtCond)] = "Abs"
full.df$BsmtExposure[is.na(full.df$BsmtExposure)] = "Abs"
full.df$BsmtFinType1[is.na(full.df$BsmtFinType1)] = "Abs"
full.df$BsmtFinType2[is.na(full.df$BsmtFinType2)] = "Abs"
```

### Valeurs manquantes MasVnrArea/MasVnrType

```{r}
summary(full.df$MasVnrArea)
```

La moyenne de la variable MasVnrArea (qui indique la surface de placage sur les façades) est de 102.2m² alors que la médiane est de 0, donc au moins la moitiée des valeurs pour cette variable sont nulles, vérifions s'il s'agit d'une erreur.

```{r}
full.df$MasVnrArea <- as.numeric(full.df$MasVnrArea)
dt_test0 <- full.df %>% filter(MasVnrArea==0)
dt_test0
```

Après avoir filtré la base de données pour ne garder que les habitations qui ont une valeur MasVnrArea égale à zéro, on remarque qu'il y a une corrélation entre les variables MasVnrArea et MasVnrType (qui indique le type de placage) : pour toutes les habitations qui ont une valeur MasVnrArea nulle, la variable MasVnrType indique "None". Donc il ne s'aggit pas d'une erreur puisque les valeurs nulles correspondent aux habitations dont les façades ne possèdent pas de placage).

On remplace les valeurs NA par "None" pour MasVnrType et par 0 pour MasVnrArea.  

```{r}
full.df$MasVnrType[is.na(full.df$MasVnrType)] = "None"
full.df$MasVnrArea[is.na(full.df$MasVnrArea)] = 0
```

En revanche, étant donné qu'il y a 24 valeurs manquantes pour le type de matériau et seulement 23 pour la surface couverte çela veut dire qu'il y a eu une erreur de saisie ou un oubli pour le matériau d'une habitation (car la surface est bien présente). 

Vérifions quels sont les matériaux les plus utilisées pour le placage

```{r}
Graph3 <- ggplot(full.df) +
 aes(x = MasVnrType) +
 geom_bar(fill = "#0c4c8a") +
 theme_minimal()
ggplotly(Graph3)
```

Ce graphique nous montre qu'au total il y a 1153 (879 + 25 + 249) habitations qui ont un placage. Le matériau le plus utilisé est clairement la brique qui représente 76% (879/1153) des placages. On peut donc affirmer avec une certitude de 76% que la valeur manquante est BrkFace, ce qui est un risque acceptable.

```{r}
full.df[2611, 26] = "BrkFace"
full.df
```


```{r}
Graph10 <- gg_miss_var(full.df)
ggplotly(Graph10)
```


### Valeur manquantes Garages

Regarder maintenant pour les valeurs manquantes concernant les garages

Pour GarageType, la valeur NA indique l'absence de garage. Il faut donc regarder pour les autres variables garages si l'absence d'informations provient de l'absence d'un garage.

Nombre de valeurs manquantes pour les variables rattachées au Garage :

GarageType	157			
GarageYrBlt	159			
GarageFinish	159			
GarageCars	1			
GarageArea	1			
GarageQual	159			
GarageCond	159

Dans un premier temps, nous indiquons "Abs" lorsque la valeur NA est présente sur la variable GarageType.

```{r}
full.df$GarageType[is.na(full.df$GarageType)] = "Abs"
```


Ensuite nous créons un jeu de données avec l'ensemble des variables Garage (voir si c'est pertinent)

```{r}
full.df[full.df$GarageType=="Abs", c("GarageYrBlt", 'GarageQual', 'GarageCond', 'GarageFinish')]
```


Nous pouvons voir que parmi toutes les valeurs Abs pour la variable GarageType, les variables GarageYrBlt, GarageQual, GarageCond et GarageFinish affichent une valeur "NA". Ainsi, nous allons pouvoir remplacer ces NA par la valeur Abs.

```{r}
full.df$GarageYrBlt[is.na(full.df$GarageYrBlt)] = "Abs"
full.df$GarageQual[is.na(full.df$GarageQual)] = "Abs"
full.df$GarageCond[is.na(full.df$GarageCond)] = "Abs"
full.df$GarageFinish[is.na(full.df$GarageFinish)] = "Abs"
```

Les variables GarageCars et GarageArea comptent chacune une valeur NA, nous allons vérifier si cette valeur NA correspond à l'absence de garage ou s'il s'agit d'une erreur de saisie lors de la création du jeu de données.

```{r}
which(is.na(full.df$GarageCars), arr.ind=TRUE)
which(is.na(full.df$GarageArea), arr.ind=TRUE)
```

Nous pouvons voir que les 2 valeurs manquantes pour les 2 variables se trouvent sur la même ligne, la ligne 2577.

```{r}
full.df[2577]
```

Sur la ligne 2577, toutes les variables relatives au Garage indiquent l'absence d'un garage excepté pour la variable GarageType qui indique "Detchd", nous pouvons donc conclure qu'il s'agit d'une erreur de saisie et que cette valeur devrait être "Abs" au lieu de "Detchd".

```{r}
full.df$GarageType[2577] <- "Abs"
full.df$GarageCars[is.na(full.df$GarageCars)] = "Abs"
full.df$GarageArea[is.na(full.df$GarageArea)] = "Abs"
```
